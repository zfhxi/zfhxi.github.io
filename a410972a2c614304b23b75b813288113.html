<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Chrome, Firefox OS and Opera Status Bar Color -->
  <meta name="theme-color" content="#FFFFFF">
  <meta property="og:title" content="Composite模式概念">
    <meta property="og:type" content="blog">
  <title>Composite模式概念</title>
  <!-- Favicon -->
    <link rel="shortcut icon" href="🏡">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
  <link rel="stylesheet" type="text/css"
    href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism-solarizedlight.min.css">
  <link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
  <link rel="stylesheet" type="text/css" href="css/notablog.css">
  <link rel="stylesheet" type="text/css" href="css/theme.css">
  <script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='https://unpkg.com/valine/dist/Valine.min.js'></script>
  <style>
    :root {
      font-size: 18px;
    }

    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
    <a href="index.html">
      <div class="Navbar__Btn"><span>🏡</span> <span>Home</span></div>
    </a>
                                                                                                                                                                                                                    <span class="Navbar__Delim">&centerdot;</span>
    <a href="about.html">
      <div class="Navbar__Btn"><span>👦🏻</span> <span>About</span></div>
    </a>
                <span class="Navbar__Delim">&centerdot;</span>
    <a href="links.html">
      <div class="Navbar__Btn"><span>🔗</span> <span>Links</span></div>
    </a>
                          </nav>
  <header class="Header">
        <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    <div>
            <span class="Header__Title">Composite模式概念</span>

    </div>
        <div class="DateTagBar">
            <span class="DateTagBar__Item DateTagBar__Date">Posted on Sun, May 17, 2020</span>
                  <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--default">
        <a href="tag/DesignPattern.html">DesignPattern</a>
      </span>
            <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--orange">
        <a href="tag/Java.html">Java</a>
      </span>
          </div>
      </header>
  <article id="https://www.notion.so/a410972a2c614304b23b75b813288113" class="PageRoot"><ul id="https://www.notion.so/559ad7180fed44d19501391b311894f3" class="ColorfulBlock ColorfulBlock--ColorGray TableOfContents"><li class="TableOfContents__Item"><a href="#https://www.notion.so/6855d0c4eb3a4bf08ad8d88f227b31de"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">目的</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/2819d4bee58e4aa28f951971faf7cff5"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">动机</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/8ccf76478fd64c739d079b1aefbd85d0"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">好处</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/7743fda8b7a1462593ed1acb15415bfb"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">模式的结构</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/9750231c732e4e1399b07d353206be1a"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">适用范围</span></span></div></a></li><li class="TableOfContents__Item"><a href="#https://www.notion.so/68364b7ae2254ca4b0132bd76c33f62e"><div style="margin-left:0px"><span class="SemanticStringArray"><span class="SemanticString">评价</span></span></div></a></li></ul><h1 id="https://www.notion.so/6855d0c4eb3a4bf08ad8d88f227b31de" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/6855d0c4eb3a4bf08ad8d88f227b31de"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">目的</span></span></h1><div id="https://www.notion.so/82a9f38e97044d8e974a2198d08fa9e2" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</span></span></p></div><h1 id="https://www.notion.so/2819d4bee58e4aa28f951971faf7cff5" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/2819d4bee58e4aa28f951971faf7cff5"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">动机</span></span></h1><div id="https://www.notion.so/fb29cf2bbf71413e8bfeafc1f7ba1150" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">在绘图编辑器和图形捕捉系统这样的图形应用系统中，用户可以使用简单的组件创建复杂的图标。用户可以组合多个简单组件以形成一些较大的组件，这些组件又可以组合成更大的组件。一个简单的实现方法是为Text和Line这样的图元定义一些类，另外定义一些类作为这些图元的容器类（Container）。
然而这种方法存在一个问题：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。对这些类区别对待，使得程序更加复杂。Composite模式描述了如何使用递归组合，使得用户不比对这些类进行区别，如下图：
</span></span></p></div><div id="https://www.notion.so/81a72fd231fd454c8dc0cc00fb156ca7" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3a1aafd9-6158-4121-a27a-25c685d0138a%2FUntitled.png?width=624&amp;table=block&amp;id=81a72fd2-31fd-454c-8dc0-cc00fb156ca7"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3a1aafd9-6158-4121-a27a-25c685d0138a%2FUntitled.png?width=624&amp;table=block&amp;id=81a72fd2-31fd-454c-8dc0-cc00fb156ca7" style="width:624px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><h1 id="https://www.notion.so/8ccf76478fd64c739d079b1aefbd85d0" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/8ccf76478fd64c739d079b1aefbd85d0"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">好处</span></span></h1><ul class="BulletedListWrapper"><li id="https://www.notion.so/8f4d412fea334985a8f78f4db55b606a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一些部件对象经过组合构成的复合部件对象仍然具有单个部件对象的接口，这样的复合部件对象称为“容器(Container)”</span></span></li><li id="https://www.notion.so/702f47748a304934af712f8519b7d07e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">复合部件与单个部件具有同样的接口，所有接口包含两部分：单个部件的功能、管理子部件的功能</span></span></li><li id="https://www.notion.so/b8481fcbbdda445a8005f9da706c5f6d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">实现递归组合</span></span></li></ul><div id="https://www.notion.so/6fede3304dac4c938d5b1b96074a149c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/7743fda8b7a1462593ed1acb15415bfb" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/7743fda8b7a1462593ed1acb15415bfb"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">模式的结构</span></span></h1><div id="https://www.notion.so/0b5c9f7186d34c329b60344b466ef47c" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe4458666-1a95-4c25-8869-ca30da93e900%2FUntitled.png?width=528&amp;table=block&amp;id=0b5c9f71-86d3-4c32-9b60-344b466ef47c"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe4458666-1a95-4c25-8869-ca30da93e900%2FUntitled.png?width=528&amp;table=block&amp;id=0b5c9f71-86d3-4c32-9b60-344b466ef47c" style="width:528px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/351eec8d3b1c4434b57b66e00e41292e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">组合模式结构如上图所示，</span></span></p></div><div id="https://www.notion.so/11fe902f9a9d4d43b2c4bb423f7b3f15" class="ColorfulBlock ColorfulBlock--BgPink Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">其包含以下主要角色：</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/0515927f56b24a448ae8bdc0c3ad9410" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">抽象构件</strong></span><span class="SemanticString">（Component）角色：它的</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为</code></span><span class="SemanticString">。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</span></span></li><li id="https://www.notion.so/2eb9fa3f7aa644859ceac74dad5f5de3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">树叶构件</strong></span><span class="SemanticString">（Leaf）角色：是组合中的叶节点对象，它没有子节点，</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">用于实现抽象构件角色中声明的公共接口</code></span><span class="SemanticString">。</span></span></li><li id="https://www.notion.so/c38dd47df70f4f22920f8757c698c5d4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">树枝构件</strong></span><span class="SemanticString">（Composite）角色：是组合中的分支节点对象，它有子节点。它</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件</code></span><span class="SemanticString">，通常包含 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Add()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Remove()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">GetChild()</code></span><span class="SemanticString"> 等方法。</span></span></li><li id="https://www.notion.so/ddb0b60c30364beea460766613d329de" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">客户端</strong></span><span class="SemanticString">（Client）角色：调用抽象构建接口的方法。</span></span></li></ul><div id="https://www.notion.so/af3e06c420ec4be69a8a27b90f5c187b" class="ColorfulBlock ColorfulBlock--BgPink Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">组合方式分类</span></span></p></div><ul class="BulletedListWrapper"><li id="https://www.notion.so/229b4a390ae6486dafae0223a723e259" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">透明式组合方式：</strong></span><span class="SemanticString">在该方式中，由于抽象构建声明了所有子类中的全部方法，所以客户端无需区别树叶对象和树枝对象，对客户端来说是透明的。</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">缺点</strong></span><span class="SemanticString">是：树叶构建本来没有 </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">add()</code></span><span class="SemanticString">、</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">remove()</code></span><span class="SemanticString"> 及</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code"> getChild() </code></span><span class="SemanticString">等方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</span></span></li><li id="https://www.notion.so/9947ee89b80d4bf68fb95261bf4efd83" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">安全式组合方式：</strong></span><span class="SemanticString">在该方式中，将管理自购件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以</span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">失去了透明性</strong></span><span class="SemanticString">。</span></span></li></ul><div id="https://www.notion.so/2b63a07d3ddc4620af9892046a54dc94" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><h1 id="https://www.notion.so/9750231c732e4e1399b07d353206be1a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/9750231c732e4e1399b07d353206be1a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">适用范围</span></span></h1><ul class="BulletedListWrapper"><li id="https://www.notion.so/a02194b4d733465597b50c062c86a116" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">想要表示对象的部分-整体层次结构</span></span></li><li id="https://www.notion.so/380ec129223f493d8a0b7905f159de6e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象</span></span></li></ul><h1 id="https://www.notion.so/68364b7ae2254ca4b0132bd76c33f62e" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--1"><a class="Anchor" href="#https://www.notion.so/68364b7ae2254ca4b0132bd76c33f62e"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">评价</span></span></h1><ul class="BulletedListWrapper"><li id="https://www.notion.so/3a7a0753845a4af2923487dfd56d5472" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">定义了包含leaf对象和composite对象的类层次接口，是一种递归结构</span></span></li><li id="https://www.notion.so/4b7dc4d2f54e46e88e40cd46b56812e6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">客户一致地处理复合对象和单个对象。</span></span></li><li id="https://www.notion.so/9914e38bb8c44fe9994cea75fcb53bb4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">易于增加新类型的组件。</span></span></li><li id="https://www.notion.so/79bf526ea4f54d098f9e6082b6a1e1b6" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">容易增加新组件也会带来问题：很难限制组合中的组件。有时希望一个组合只能有某些特定的组件，使用Composite时，不能依赖类型系统施加的这些约束，而必须在运行时刻进行检查。</span></span></li></ul><div id="https://www.notion.so/28b544b0338947b6b9cfa37b56d74e14" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/58e247bf6217455c891a0fc4c49b64b4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">实现见后文。</span></span></p></div><div id="https://www.notion.so/e960cd24ee9149148479b48ea8fa9878" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">参考文章：</span></span></p></div><div id="https://www.notion.so/ebdf8a31c44a4a7687f7da59bd1b879c" class="Bookmark"><a href="https://blog.csdn.net/z55887/article/details/70548861"><h5 class="Bookmark__Title">Head First 设计模式（九）迭代器与组合模式_Java_大树的学习之路-CSDN博客</h5><p class="Bookmark__Desc">迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示 迭代器模式我们很熟悉，其实就是Java中集合的迭代原理，如果你研究过集合的源码，就会很容易理解这个模式。 现在有两家餐厅：煎饼店和饭店，它们想要合并。两家店的菜单需要统一起来，以便服务员给客户看。 但此时有一个问题，煎饼店和饭店的菜单，实现是不一样的： 从代码我们可以看出，两家店的菜单一个是数组实现，一个是集合实现。 这时，我们想要服务员提供新的菜单时，得分别针对两种不同的底层实现，进行不同的迭代： /** * 打印出菜单 */ public void printMenu() { ArrayList pMenuItems = pancakeMenu.menuItems; for (int i = 0; i &lt; pMenuItems.size(); i++) { MenuItem menuItem = pMenuItems.get(i); System.out.println(menuItem.getName()+&quot;:&quot;+menuItem.getPrice()); } MenuItem[] dMenuItems = dinnerMenu.menuItems; for (int i = 0,n = dMenuItems.length; i &lt; n; i++) {</p><p class="Bookmark__Link">https://blog.csdn.net/z55887/article/details/70548861</p></a></div><div id="https://www.notion.so/ed06c6cc593f4bcea59c72081ca128b6" class="Bookmark"><a href="https://www.cnblogs.com/wuqinglong/p/12425411.html"><h5 class="Bookmark__Title">https://www.cnblogs.com/wuqinglong/p/12425411.html</h5><p class="Bookmark__Link">https://www.cnblogs.com/wuqinglong/p/12425411.html</p></a></div></article>  <div id="vcomments"></div>
  <script>
    new Valine({
      el: '#vcomments',
      appId: 'x3yNlOp8snKVbHLuM3MDgyPm-gzGzoHsz',
      appKey: 'IxbPmtJ4C181kqwCPyUfHb67',
      avatar: 'retro',
      placeholder: 'Welcome to comment here233!',
      requiredFields: ['nick', 'mail']
    })
  </script>
  <footer class="Footer">
    <div>&copy; idzc.me 2020</div>
    <div>&centerdot;</div>
    <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
        rel="noopener noreferrer">Notablog</a>.
    </div>
  </footer>
</body>

</html>